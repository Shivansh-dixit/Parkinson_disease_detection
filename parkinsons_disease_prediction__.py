# -*- coding: utf-8 -*-
"""Parkinsons Disease Prediction__.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pkMznOBWr-aXzShLj9XNYQS_FBj5sIn8
"""

import numpy as np
import pandas as pd
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn import svm
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, classification_report

df=pd.read_csv("parkinsons.csv")

df

df.head()

df.describe()

df.info()

#to see all the rows
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
df

df.shape

df.isnull().sum()
#there is no null value ... so it is a good dataset

#'value_counts()' method in Pandas is used to get a Series containing the counts of unique values in a column
df['status'].value_counts()
# 1: those who are affected by partition
# 0: those who are not affected by partition

#df is the DataFrame you have created, which contains your data.
#status is the column name based on which you want to group the DataFrame.
#.groupby('status') groups the DataFrame 'df' based on unique values in the 'status' column.
#.mean() calculates the mean for each group separately
df.groupby('status').mean(numeric_only=True)

X=df.drop(columns=['name', 'status'],axis=1)
Y=df['status']

print(X)

print(Y)

X_train, X_test, Y_train,Y_test= train_test_split(X,Y, test_size=0.2,random_state=2)

print(X.shape,X_train.shape,X_test.shape)

ss=StandardScaler()

# data standardization
# Process of transforming data into standardized format so that user may process any value
#fit training data into it
ss.fit(X_train)

X_train=ss.transform(X_train)
X_test=ss.transform(X_test)

print(X_train)

print(X_test)

"""# SVM(Support vector machine) Model"""

#SVM(Support vector machine is used. It is used in email, web pages, handwriting recognization, page identification, gene classification)
SVM=svm.SVC(kernel='linear')

SVM.fit(X_train, Y_train)

#model evaluation
#by prediction check the accuracy of train and test data
X_train_pred=SVM.predict(X_train)
train_data_acc=accuracy_score(Y_train, X_train_pred)

print("acc of training data : ", train_data_acc)

X_test_pred=SVM.predict(X_test)
test_data_acc=accuracy_score(Y_test,X_test_pred)

print("accuracy of testing data: ",test_data_acc)

# Generate the classification report
Y_pred = SVM.predict(X_test)
report = classification_report(Y_test, Y_pred)

# Print the classification report
print("Classification Report:")
print(report)

import matplotlib.pyplot as plt
from sklearn.metrics import classification_report
# Generate the classification report
report = classification_report(Y_test, Y_pred, output_dict=True)
# Convert the classification report to a DataFrame for visualization
report_df = pd.DataFrame(report).transpose()

# Plot the heatmap
plt.figure(figsize=(8, 5))
sns.heatmap(report_df.iloc[:-1, :].T, annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.xlabel('Metrics')
plt.ylabel('Class')
plt.title('Classification Report - SVM Model')
plt.show()

from sklearn.metrics import f1_score, accuracy_score, precision_score, recall_score
# Predict on the test set
Y_pred = SVM.predict(X_test)
# Calculate F1-score
f1 = f1_score(Y_test, Y_pred)

# Calculate Classification Accuracy (CA)
ca = accuracy_score(Y_test, Y_pred)

# Calculate Precision
precision = precision_score(Y_test, Y_pred)

# Calculate Recall
recall = recall_score(Y_test, Y_pred)

# Print the results
print("F1-score:", f1)
print("Classification Accuracy (CA):", ca)
print("Precision:", precision)
print("Recall:", recall)

input_data=(217.11600,233.48100,93.97800,0.00404,0.00002,0.00127,0.00128,0.00381,0.01299,0.12400,0.00679,0.00631,0.01075,0.02038,0.00681,24.58100,0.462516,0.582710,-5.517173,0.389295,2.925862,0.220657)
input_data_np=np.asarray(input_data)
input_data_re=input_data_np.reshape(1,-1)
s_data=ss.transform(input_data_re)
pred=SVM.predict(s_data)
print(pred)
if(pred[0]==0):
    print("Negative, No Parkinsons found")
else:
    print("Positive, Parkinsons found")

input_data=(229.40100,252.22100,221.15600,0.00205,0.000009,0.00114,0.00113,0.00342,0.01457,0.12900,0.00769,0.00957,0.01016,0.02308,0.00300,26.41500,0.276850,0.673636,-7.496264,0.056844,2.003032,0.073581)
input_data_np=np.asarray(input_data)
input_data_re=input_data_np.reshape(1,-1)
s_data=ss.transform(input_data_re)
pred=SVM.predict(s_data)
print(pred)
if(pred[0]==0):
    print("Negative, No Parkinsons found")
else:
    print("Positive, Parkinsons found")

"""# Logistic Regression"""

#Logistic Regression: predict the probability that an instance belongs to a particular class
# Create and train the logistic regression model
logreg = LogisticRegression()
logreg.fit(X_train, Y_train)

# Predict on the test set
Y_pred = logreg.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(Y_test, Y_pred)
print("Accuracy:", accuracy)

report = classification_report(Y_test, Y_pred)
print("Classification Report:\n", report)

from sklearn.metrics import f1_score, accuracy_score, precision_score, recall_score

# Create and train the Logistic Regression model
logreg_model = LogisticRegression(random_state=42)
logreg_model.fit(X_train, Y_train)
# Predict on the test set
Y_pred = logreg_model.predict(X_test)

# Calculate F1-score
f1 = f1_score(Y_test, Y_pred)

# Calculate Classification Accuracy (CA)
ca = accuracy_score(Y_test, Y_pred)

# Calculate Precision
precision = precision_score(Y_test, Y_pred)

# Calculate Recall
recall = recall_score(Y_test, Y_pred)

# Print the results
print("F1-score:", f1)
print("Classification Accuracy (CA):", ca)
print("Precision:", precision)
print("Recall:", recall)

input_data=(217.11600,233.48100,93.97800,0.00404,0.00002,0.00127,0.00128,0.00381,0.01299,0.12400,0.00679,0.00631,0.01075,0.02038,0.00681,24.58100,0.462516,0.582710,-5.517173,0.389295,2.925862,0.220657)
input_data_np=np.asarray(input_data)
input_data_re=input_data_np.reshape(1,-1)
s_data=ss.transform(input_data_re)
pred=logreg_model.predict(s_data)
print(pred)
if(pred[0]==0):
    print("Negative, No Parkinsons found")
else:
    print("Positive, Parkinsons found")

input_data=(229.40100,252.22100,221.15600,0.00205,0.000009,0.00114,0.00113,0.00342,0.01457,0.12900,0.00769,0.00957,0.01016,0.02308,0.00300,26.41500,0.276850,0.673636,-7.496264,0.056844,2.003032,0.073581)
input_data_np=np.asarray(input_data)
input_data_re=input_data_np.reshape(1,-1)
s_data=ss.transform(input_data_re)
pred=logreg_model.predict(s_data)
print(pred)
if(pred[0]==0):
    print("Negative, No Parkinsons found")
else:
    print("Positive, Parkinsons found")

"""# KNN(K-Nearest Neighbors)"""

# Train the KNN classifier
knn = KNeighborsClassifier(n_neighbors=5)  #Let's start with k=5
knn.fit(X_train, Y_train)

# Predict on the test set
Y_pred = knn.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(Y_test, Y_pred)
print("Accuracy:", accuracy)

report = classification_report(Y_test, Y_pred)
print("Classification Report:\n", report)

from sklearn.metrics import f1_score, accuracy_score, precision_score, recall_score
# Create and train the KNN model
knn_model = KNeighborsClassifier(n_neighbors=5)  # You can set the number of neighbors (n_neighbors) as needed
knn_model.fit(X_train, Y_train)

# Predict on the test set
Y_pred = knn_model.predict(X_test)

# Calculate F1-score
f1 = f1_score(Y_test, Y_pred)

# Calculate Classification Accuracy (CA)
ca = accuracy_score(Y_test, Y_pred)

# Calculate Precision
precision = precision_score(Y_test, Y_pred)

# Calculate Recall
recall = recall_score(Y_test, Y_pred)

# Print the results
print("F1-score:", f1)
print("Classification Accuracy (CA):", ca)
print("Precision:", precision)
print("Recall:", recall)

input_data=(217.11600,233.48100,93.97800,0.00404,0.00002,0.00127,0.00128,0.00381,0.01299,0.12400,0.00679,0.00631,0.01075,0.02038,0.00681,24.58100,0.462516,0.582710,-5.517173,0.389295,2.925862,0.220657)
input_data_np=np.asarray(input_data)
input_data_re=input_data_np.reshape(1,-1)
s_data=ss.transform(input_data_re)
pred=knn.predict(s_data)
print(pred)
if(pred[0]==0):
    print("Negative, No Parkinsons found")
else:
    print("Positive, Parkinsons found")

input_data=(229.40100,252.22100,221.15600,0.00205,0.000009,0.00114,0.00113,0.00342,0.01457,0.12900,0.00769,0.00957,0.01016,0.02308,0.00300,26.41500,0.276850,0.673636,-7.496264,0.056844,2.003032,0.073581)
input_data_np=np.asarray(input_data)
input_data_re=input_data_np.reshape(1,-1)
s_data=ss.transform(input_data_re)
pred=knn.predict(s_data)
print(pred)
if(pred[0]==0):
    print("Negative, No Parkinsons found")
else:
    print("Positive, Parkinsons found")